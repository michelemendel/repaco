// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Block = require("bs-platform/lib/js/block.js");
var Parser$Repaco = require("../src/Parser.bs.js");

Jest.describe("Success with sequence of two parsers", (function (param) {
        var input = "ABCDEF";
        var parseA = function (param) {
          return Parser$Repaco.pchar("A", param);
        };
        var parseB = function (param) {
          return Parser$Repaco.pchar("B", param);
        };
        var actual = Parser$Repaco.$neg$great$great$neg(parseA, parseB, input);
        var expected = /* Success */Block.__(0, [/* tuple */[
              "A",
              "B",
              "CDEF"
            ]]);
        return Jest.test("succeed with ABCDEF", (function (param) {
                      return Jest.Expect[/* toEqual */12](expected, Jest.Expect[/* expect */0](actual));
                    }));
      }));

Jest.describe("Failure with sequence of two parsers on first character", (function (param) {
        var input = "ZBCDEF";
        var firstChar = input.charAt(0);
        var charToMatchA = "A";
        var parseA = function (param) {
          return Parser$Repaco.pchar(charToMatchA, param);
        };
        var parseB = function (param) {
          return Parser$Repaco.pchar("B", param);
        };
        var actual = Parser$Repaco.$neg$great$great$neg(parseA, parseB, input);
        var expected = /* Failure */Block.__(1, ["Expecting " + (String(charToMatchA) + (", got " + (String(firstChar) + "")))]);
        return Jest.test("fail with ZBCDEF", (function (param) {
                      return Jest.Expect[/* toEqual */12](expected, Jest.Expect[/* expect */0](actual));
                    }));
      }));

Jest.describe("Failure with sequence of two parsers on second character", (function (param) {
        var input = "AZCDEF";
        var secondChar = input.charAt(1);
        var charToMatchB = "B";
        var parseA = function (param) {
          return Parser$Repaco.pchar("A", param);
        };
        var parseB = function (param) {
          return Parser$Repaco.pchar(charToMatchB, param);
        };
        var actual = Parser$Repaco.$neg$great$great$neg(parseA, parseB, input);
        var expected = /* Failure */Block.__(1, ["Expecting " + (String(charToMatchB) + (", got " + (String(secondChar) + "")))]);
        return Jest.test("fail with AZCDEF", (function (param) {
                      return Jest.Expect[/* toEqual */12](expected, Jest.Expect[/* expect */0](actual));
                    }));
      }));

/*  Not a pure module */
